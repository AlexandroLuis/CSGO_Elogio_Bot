(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.BbobParser = {})));
}(this, (function (exports) { 'use strict';

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var char_1 = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	var N = '\n';
	var TAB = '\t';
	var F = '\f';
	var R = '\r';

	var EQ = '=';
	var QUOTEMARK = '"';
	var SPACE = ' ';

	var OPEN_BRAKET = '[';
	var CLOSE_BRAKET = ']';

	var SLASH = '/';
	var BACKSLASH = '\\';

	var PLACEHOLDER_SPACE_TAB = '    ';
	var PLACEHOLDER_SPACE = ' ';

	// const getChar = String.fromCharCode;

	exports.N = N;
	exports.F = F;
	exports.R = R;
	exports.TAB = TAB;
	exports.EQ = EQ;
	exports.QUOTEMARK = QUOTEMARK;
	exports.SPACE = SPACE;
	exports.OPEN_BRAKET = OPEN_BRAKET;
	exports.CLOSE_BRAKET = CLOSE_BRAKET;
	exports.SLASH = SLASH;
	exports.PLACEHOLDER_SPACE_TAB = PLACEHOLDER_SPACE_TAB;
	exports.PLACEHOLDER_SPACE = PLACEHOLDER_SPACE;
	exports.BACKSLASH = BACKSLASH;
	});

	unwrapExports(char_1);
	var char_2 = char_1.N;
	var char_3 = char_1.F;
	var char_4 = char_1.R;
	var char_5 = char_1.TAB;
	var char_6 = char_1.EQ;
	var char_7 = char_1.QUOTEMARK;
	var char_8 = char_1.SPACE;
	var char_9 = char_1.OPEN_BRAKET;
	var char_10 = char_1.CLOSE_BRAKET;
	var char_11 = char_1.SLASH;
	var char_12 = char_1.PLACEHOLDER_SPACE_TAB;
	var char_13 = char_1.PLACEHOLDER_SPACE;
	var char_14 = char_1.BACKSLASH;

	var lib = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	exports.isEOL = exports.isStringNode = exports.isTagNode = exports.getNodeLength = exports.appendToNode = exports.attrValue = exports.attrsToString = undefined;



	var isTagNode = function isTagNode(el) {
	  return typeof el === 'object' && !!el.tag;
	};
	var isStringNode = function isStringNode(el) {
	  return typeof el === 'string';
	};
	var isEOL = function isEOL(el) {
	  return el === char_1.N;
	};

	var getNodeLength = function getNodeLength(node) {
	  if (isTagNode(node)) {
	    return node.content.reduce(function (count, contentNode) {
	      return count + getNodeLength(contentNode);
	    }, 0);
	  } else if (isStringNode(node)) {
	    return node.length;
	  }

	  return 0;
	};

	/**
	 * Appends value to Tag Node
	 * @param {TagNode} node
	 * @param value
	 */
	var appendToNode = function appendToNode(node, value) {
	  node.content.push(value);
	};

	/**
	 * Replaces " to &qquot;
	 * @param {String} value
	 */
	var escapeQuote = function escapeQuote(value) {
	  return value.replace(/"/g, '&quot;');
	};

	/**
	 * Acept name and value and return valid html5 attribute string
	 * @param {String} name
	 * @param {String} value
	 * @return {string}
	 */
	var attrValue = function attrValue(name, value) {
	  var type = typeof value;

	  var types = {
	    boolean: function boolean() {
	      return value ? '' + name : '';
	    },
	    number: function number() {
	      return name + '="' + value + '"';
	    },
	    string: function string() {
	      return name + '="' + escapeQuote(value) + '"';
	    },
	    object: function object() {
	      return name + '="' + escapeQuote(JSON.stringify(value)) + '"';
	    }
	  };

	  return types[type] ? types[type]() : '';
	};

	/**
	 * Transforms attrs to html params string
	 * @param values
	 */
	var attrsToString = function attrsToString(values) {
	  // To avoid some malformed attributes
	  if (typeof values === 'undefined') {
	    return '';
	  }

	  return Object.keys(values).reduce(function (arr, key) {
	    return [].concat(arr, [attrValue(key, values[key])]);
	  }, ['']).join(' ');
	};

	exports.attrsToString = attrsToString;
	exports.attrValue = attrValue;
	exports.appendToNode = appendToNode;
	exports.getNodeLength = getNodeLength;
	exports.isTagNode = isTagNode;
	exports.isStringNode = isStringNode;
	exports.isEOL = isEOL;
	});

	unwrapExports(lib);
	var lib_1 = lib.isEOL;
	var lib_2 = lib.isStringNode;
	var lib_3 = lib.isTagNode;
	var lib_4 = lib.getNodeLength;
	var lib_5 = lib.appendToNode;
	var lib_6 = lib.attrValue;
	var lib_7 = lib.attrsToString;

	var TagNode_1 = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	exports.TagNode = undefined;

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();





	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	var TagNode = function () {
	  function TagNode(tag, attrs, content) {
	    _classCallCheck(this, TagNode);

	    this.tag = tag.toLowerCase();
	    this.attrs = attrs;
	    this.content = [].concat(content);
	  }

	  TagNode.prototype.attr = function attr(name, value) {
	    if (typeof value !== 'undefined') {
	      this.attrs[name] = value;
	    }

	    return this.attrs[name];
	  };

	  TagNode.prototype.append = function append(value) {
	    return (0, lib.appendToNode)(this, value);
	  };

	  TagNode.prototype.toString = function toString() {
	    var OB = char_1.OPEN_BRAKET;
	    var CB = char_1.CLOSE_BRAKET;

	    return OB + this.tag + CB + this.content.reduce(function (r, node) {
	      return r + node.toString();
	    }, '') + OB + char_1.SLASH + this.tag + CB;
	  };

	  _createClass(TagNode, [{
	    key: 'length',
	    get: function get() {
	      return (0, lib.getNodeLength)(this);
	    }
	  }]);

	  return TagNode;
	}();

	TagNode.create = function (tag) {
	  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var content = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
	  return new TagNode(tag, attrs, content);
	};
	TagNode.isOf = function (node, type) {
	  return node.tag === type;
	};

	exports.TagNode = TagNode;
	exports.default = TagNode;
	});

	var TagNode = unwrapExports(TagNode_1);
	var TagNode_2 = TagNode_1.TagNode;

	var classCallCheck = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

	// type, value, line, row,
	var TOKEN_TYPE_ID = 'type'; // 0;
	var TOKEN_VALUE_ID = 'value'; // 1;
	var TOKEN_COLUMN_ID = 'row'; // 2;
	var TOKEN_LINE_ID = 'line'; // 3;

	var TOKEN_TYPE_WORD = 'word';
	var TOKEN_TYPE_TAG = 'tag';
	var TOKEN_TYPE_ATTR_NAME = 'attr-name';
	var TOKEN_TYPE_ATTR_VALUE = 'attr-value';
	var TOKEN_TYPE_SPACE = 'space';
	var TOKEN_TYPE_NEW_LINE = 'new-line';

	var getTokenValue = function getTokenValue(token) {
	  return token[TOKEN_VALUE_ID];
	};
	var getTokenLine = function getTokenLine(token) {
	  return token[TOKEN_LINE_ID];
	};
	var getTokenColumn = function getTokenColumn(token) {
	  return token[TOKEN_COLUMN_ID];
	};

	var isTextToken = function isTextToken(token) {
	  return token[TOKEN_TYPE_ID] === TOKEN_TYPE_SPACE || token[TOKEN_TYPE_ID] === TOKEN_TYPE_NEW_LINE || token[TOKEN_TYPE_ID] === TOKEN_TYPE_WORD;
	};

	var isTagToken = function isTagToken(token) {
	  return token[TOKEN_TYPE_ID] === TOKEN_TYPE_TAG;
	};
	var isTagEnd = function isTagEnd(token) {
	  return getTokenValue(token).charCodeAt(0) === char_11.charCodeAt(0);
	};
	var isTagStart = function isTagStart(token) {
	  return !isTagEnd(token);
	};
	var isAttrNameToken = function isAttrNameToken(token) {
	  return token[TOKEN_TYPE_ID] === TOKEN_TYPE_ATTR_NAME;
	};
	var isAttrValueToken = function isAttrValueToken(token) {
	  return token[TOKEN_TYPE_ID] === TOKEN_TYPE_ATTR_VALUE;
	};

	var getTagName = function getTagName(token) {
	  var value = getTokenValue(token);

	  return isTagEnd(token) ? value.slice(1) : value;
	};

	var convertTagToText = function convertTagToText(token) {
	  var text = char_9;

	  text += getTokenValue(token);
	  text += char_10;

	  return text;
	};

	var Token = function () {
	  /**
	   * @param {String} type
	   * @param {String} value
	   * @param line
	   * @param row
	   */
	  function Token(type, value, line, row) {
	    classCallCheck(this, Token);

	    this[TOKEN_TYPE_ID] = String(type);
	    this[TOKEN_VALUE_ID] = String(value);
	    this[TOKEN_LINE_ID] = Number(line);
	    this[TOKEN_COLUMN_ID] = Number(row);
	  }

	  Token.prototype.isEmpty = function isEmpty() {
	    return !!this[TOKEN_TYPE_ID];
	  };

	  Token.prototype.isText = function isText() {
	    return isTextToken(this);
	  };

	  Token.prototype.isTag = function isTag() {
	    return isTagToken(this);
	  };

	  Token.prototype.isAttrName = function isAttrName() {
	    return isAttrNameToken(this);
	  };

	  Token.prototype.isAttrValue = function isAttrValue() {
	    return isAttrValueToken(this);
	  };

	  Token.prototype.isStart = function isStart() {
	    return isTagStart(this);
	  };

	  Token.prototype.isEnd = function isEnd() {
	    return isTagEnd(this);
	  };

	  Token.prototype.getName = function getName() {
	    return getTagName(this);
	  };

	  Token.prototype.getValue = function getValue() {
	    return getTokenValue(this);
	  };

	  Token.prototype.getLine = function getLine() {
	    return getTokenLine(this);
	  };

	  Token.prototype.getColumn = function getColumn() {
	    return getTokenColumn(this);
	  };

	  Token.prototype.toString = function toString() {
	    return convertTagToText(this);
	  };

	  return Token;
	}();
	var TYPE_WORD = TOKEN_TYPE_WORD;
	var TYPE_TAG = TOKEN_TYPE_TAG;
	var TYPE_ATTR_NAME = TOKEN_TYPE_ATTR_NAME;
	var TYPE_ATTR_VALUE = TOKEN_TYPE_ATTR_VALUE;
	var TYPE_SPACE = TOKEN_TYPE_SPACE;
	var TYPE_NEW_LINE = TOKEN_TYPE_NEW_LINE;

	/**
	 * @typedef {Object} CharGrabber
	 * @property {Function} skip
	 * @property {Function} hasNext
	 * @property {Function} isLast
	 * @property {Function} grabWhile
	 */

	/**
	 * Creates a grabber wrapper for source string, that helps to iterate over string char by char
	 * @param {String} source
	 * @param {Object} options
	 * @param {Function} options.onSkip
	 * @returns
	 */
	var createCharGrabber = function createCharGrabber(source, options) {
	  // let idx = 0;
	  var cursor = {
	    pos: 0,
	    length: source.length
	  };

	  var skip = function skip() {
	    cursor.pos += 1;

	    if (options && options.onSkip) {
	      options.onSkip();
	    }
	  };
	  var hasNext = function hasNext() {
	    return cursor.length > cursor.pos;
	  };
	  var getRest = function getRest() {
	    return source.substr(cursor.pos);
	  };
	  var getCurr = function getCurr() {
	    return source[cursor.pos];
	  };

	  return {
	    skip: skip,
	    hasNext: hasNext,
	    isLast: function isLast() {
	      return cursor.pos === cursor.length;
	    },
	    /**
	     * @param {Function} cond
	     * @returns {string}
	     */
	    grabWhile: function grabWhile(cond) {
	      var start = 0;

	      if (hasNext()) {
	        start = cursor.pos;

	        while (hasNext() && cond(getCurr())) {
	          skip();
	        }
	      }

	      return source.substr(start, cursor.pos - start);
	    },
	    getNext: function getNext() {
	      return source[cursor.pos + 1];
	    },
	    getPrev: function getPrev() {
	      return source[cursor.pos - 1];
	    },
	    getCurr: getCurr,
	    getRest: getRest,
	    /**
	     * Grabs rest of string until it find a char
	     * @param {String} char
	     * @return {String}
	     */
	    substrUntilChar: function substrUntilChar(char$$1) {
	      var restStr = getRest();
	      var indexOfChar = restStr.indexOf(char$$1);

	      if (indexOfChar >= 0) {
	        return restStr.substr(0, indexOfChar);
	      }

	      return '';
	    }
	  };
	};

	/**
	 * Trims string from start and end by char
	 * @example
	 *  trimChar('*hello*', '*') ==> 'hello'
	 * @param {String} str
	 * @param {String} charToRemove
	 * @returns {String}
	 */
	var trimChar = function trimChar(str, charToRemove) {
	  while (str.charAt(0) === charToRemove) {
	    // eslint-disable-next-line no-param-reassign
	    str = str.substring(1);
	  }

	  while (str.charAt(str.length - 1) === charToRemove) {
	    // eslint-disable-next-line no-param-reassign
	    str = str.substring(0, str.length - 1);
	  }

	  return str;
	};

	/**
	 * Unquotes \" to "
	 * @param str
	 * @return {String}
	 */
	var unquote = function unquote(str) {
	  return str.replace(char_14 + char_7, char_7);
	};

	/**
	 * @typedef {Object} ItemList
	 * @type {Object}
	 * @property {getLastCb} getLast
	 * @property {flushLastCb} flushLast
	 * @property {pushCb} push
	 * @property {toArrayCb} toArray
	 */

	/**
	 *
	 * @param values
	 * @return {ItemList}
	 */
	var createList = function createList() {
	  var values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

	  var nodes = values;
	  /**
	   * @callback getLastCb
	   */
	  var getLast = function getLast() {
	    return nodes.length ? nodes[nodes.length - 1] : null;
	  };
	  /**
	   * @callback flushLastCb
	   * @return {*}
	   */
	  var flushLast = function flushLast() {
	    if (nodes.length) {
	      return nodes.pop();
	    }

	    return false;
	  };
	  /**
	   * @callback pushCb
	   * @param value
	   */
	  var push = function push(value) {
	    return nodes.push(value);
	  };

	  /**
	   * @callback toArrayCb
	   * @return {Array}
	   */

	  return {
	    getLast: getLast,
	    flushLast: flushLast,
	    push: push,
	    toArray: function toArray() {
	      return nodes;
	    }
	  };
	};

	/* eslint-disable no-plusplus,no-param-reassign */

	// for cases <!-- -->
	var EM = '!';

	/**
	 * Creates a Token entity class
	 * @param {String} type
	 * @param {String} value
	 * @param {Number} r line number
	 * @param {Number} cl char number in line
	 */
	var createToken = function createToken(type, value) {
	  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	  var cl = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
	  return new Token(type, value, r, cl);
	};

	/**
	 * @typedef {Object} Lexer
	 * @property {Function} tokenize
	 * @property {Function} isTokenNested
	 */

	/**
	 * @param {String} buffer
	 * @param {Object} options
	 * @param {Function} options.onToken
	 * @param {String} options.openTag
	 * @param {String} options.closeTag
	 * @param {Boolean} options.enableEscapeTags
	 * @return {Lexer}
	 */
	function createLexer(buffer) {
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  var row = 0;
	  var col = 0;

	  var tokenIndex = -1;
	  var tokens = new Array(Math.floor(buffer.length));
	  var openTag = options.openTag || char_9;
	  var closeTag = options.closeTag || char_10;
	  var escapeTags = options.enableEscapeTags;

	  var RESERVED_CHARS = [closeTag, openTag, char_7, char_14, char_8, char_5, char_6, char_2, EM];
	  var NOT_CHAR_TOKENS = [
	  // ...(options.enableEscapeTags ? [BACKSLASH] : []),
	  openTag, char_8, char_5, char_2];
	  var WHITESPACES = [char_8, char_5];
	  var SPECIAL_CHARS = [char_6, char_8, char_5];

	  var isCharReserved = function isCharReserved(char$$1) {
	    return RESERVED_CHARS.indexOf(char$$1) >= 0;
	  };
	  var isWhiteSpace = function isWhiteSpace(char$$1) {
	    return WHITESPACES.indexOf(char$$1) >= 0;
	  };
	  var isCharToken = function isCharToken(char$$1) {
	    return NOT_CHAR_TOKENS.indexOf(char$$1) === -1;
	  };
	  var isSpecialChar = function isSpecialChar(char$$1) {
	    return SPECIAL_CHARS.indexOf(char$$1) >= 0;
	  };
	  var isEscapableChar = function isEscapableChar(char$$1) {
	    return char$$1 === openTag || char$$1 === closeTag || char$$1 === char_14;
	  };
	  var isEscapeChar = function isEscapeChar(char$$1) {
	    return char$$1 === char_14;
	  };

	  /**
	   * Emits newly created token to subscriber
	   * @param token
	   */
	  var emitToken = function emitToken(token) {
	    if (options.onToken) {
	      options.onToken(token);
	    }

	    tokenIndex += 1;
	    tokens[tokenIndex] = token;
	  };

	  /**
	   * Parses params inside [myTag---params goes here---]content[/myTag]
	   * @param str
	   * @returns {{tag: *, attrs: Array}}
	   */
	  var parseAttrs = function parseAttrs(str) {
	    var tagName = null;
	    var skipSpecialChars = false;

	    var attrTokens = [];
	    var attrCharGrabber = createCharGrabber(str);

	    var validAttr = function validAttr(char$$1) {
	      var isEQ = char$$1 === char_6;
	      var isWS = isWhiteSpace(char$$1);
	      var prevChar = attrCharGrabber.getPrev();
	      var nextChar = attrCharGrabber.getNext();
	      var isPrevSLASH = prevChar === char_14;
	      var isTagNameEmpty = tagName === null;

	      if (isTagNameEmpty) {
	        return (isEQ || isWS || attrCharGrabber.isLast()) === false;
	      }

	      if (skipSpecialChars && isSpecialChar(char$$1)) {
	        return true;
	      }

	      if (char$$1 === char_7 && !isPrevSLASH) {
	        skipSpecialChars = !skipSpecialChars;

	        if (!skipSpecialChars && !(nextChar === char_6 || isWhiteSpace(nextChar))) {
	          return false;
	        }
	      }

	      return (isEQ || isWS) === false;
	    };

	    var nextAttr = function nextAttr() {
	      var attrStr = attrCharGrabber.grabWhile(validAttr);
	      var currChar = attrCharGrabber.getCurr();

	      // first string before space is a tag name [tagName params...]
	      if (tagName === null) {
	        tagName = attrStr;
	      } else if (isWhiteSpace(currChar) || currChar === char_7 || !attrCharGrabber.hasNext()) {
	        var escaped = unquote(trimChar(attrStr, char_7));
	        attrTokens.push(createToken(TYPE_ATTR_VALUE, escaped, row, col));
	      } else {
	        attrTokens.push(createToken(TYPE_ATTR_NAME, attrStr, row, col));
	      }

	      attrCharGrabber.skip();
	    };

	    while (attrCharGrabber.hasNext()) {
	      nextAttr();
	    }

	    return { tag: tagName, attrs: attrTokens };
	  };

	  var bufferGrabber = createCharGrabber(buffer, {
	    onSkip: function onSkip() {
	      col++;
	    }
	  });

	  var next = function next() {
	    var currChar = bufferGrabber.getCurr();
	    var nextChar = bufferGrabber.getNext();

	    if (currChar === char_2) {
	      bufferGrabber.skip();
	      col = 0;
	      row++;

	      emitToken(createToken(TYPE_NEW_LINE, currChar, row, col));
	    } else if (isWhiteSpace(currChar)) {
	      var str = bufferGrabber.grabWhile(isWhiteSpace);
	      emitToken(createToken(TYPE_SPACE, str, row, col));
	    } else if (escapeTags && isEscapeChar(currChar) && isEscapableChar(nextChar)) {
	      bufferGrabber.skip(); // skip the \ without emitting anything
	      bufferGrabber.skip(); // skip past the [, ] or \ as well
	      emitToken(createToken(TYPE_WORD, nextChar, row, col));
	    } else if (currChar === openTag) {
	      bufferGrabber.skip(); // skip openTag

	      // detect case where we have '[My word [tag][/tag]' or we have '[My last line word'
	      var substr = bufferGrabber.substrUntilChar(closeTag);
	      var hasInvalidChars = substr.length === 0 || substr.indexOf(openTag) >= 0;

	      if (isCharReserved(nextChar) || hasInvalidChars || bufferGrabber.isLast()) {
	        emitToken(createToken(TYPE_WORD, currChar, row, col));
	      } else {
	        var _str = bufferGrabber.grabWhile(function (val) {
	          return val !== closeTag;
	        });

	        bufferGrabber.skip(); // skip closeTag
	        // [myTag   ]
	        var isNoAttrsInTag = _str.indexOf(char_6) === -1;
	        // [/myTag]
	        var isClosingTag = _str[0] === char_11;

	        if (isNoAttrsInTag || isClosingTag) {
	          emitToken(createToken(TYPE_TAG, _str, row, col));
	        } else {
	          var parsed = parseAttrs(_str);

	          emitToken(createToken(TYPE_TAG, parsed.tag, row, col));

	          parsed.attrs.map(emitToken);
	        }
	      }
	    } else if (currChar === closeTag) {
	      bufferGrabber.skip(); // skip closeTag

	      emitToken(createToken(TYPE_WORD, currChar, row, col));
	    } else if (isCharToken(currChar)) {
	      if (escapeTags && isEscapeChar(currChar) && !isEscapableChar(nextChar)) {
	        bufferGrabber.skip();
	        emitToken(createToken(TYPE_WORD, currChar, row, col));
	      } else {
	        var _str2 = bufferGrabber.grabWhile(function (char$$1) {
	          if (escapeTags) {
	            return isCharToken(char$$1) && !isEscapeChar(char$$1);
	          }
	          return isCharToken(char$$1);
	        });

	        emitToken(createToken(TYPE_WORD, _str2, row, col));
	      }
	    }
	  };

	  var tokenize = function tokenize() {
	    while (bufferGrabber.hasNext()) {
	      next();
	    }

	    tokens.length = tokenIndex + 1;

	    return tokens;
	  };

	  var isTokenNested = function isTokenNested(token) {
	    var value = openTag + char_11 + token.getValue();
	    // potential bottleneck
	    return buffer.indexOf(value) > -1;
	  };

	  return {
	    tokenize: tokenize,
	    isTokenNested: isTokenNested
	  };
	}

	/**
	 * @public
	 * @param {String} input
	 * @param {Object} opts
	 * @param {Function} opts.createTokenizer
	 * @param {Array<string>} opts.onlyAllowTags
	 * @param {String} opts.openTag
	 * @param {String} opts.closeTag
	 * @param {Boolean} opts.enableEscapeTags
	 * @return {Array}
	 */
	var parse = function parse(input) {
	  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  var options = opts;

	  var tokenizer = null;

	  /**
	   * Result AST of nodes
	   * @private
	   * @type {ItemList}
	   */
	  var nodes = createList();
	  /**
	   * Temp buffer of nodes that's nested to another node
	   * @private
	   * @type {ItemList}
	   */
	  var nestedNodes = createList();
	  /**
	   * Temp buffer of nodes [tag..]...[/tag]
	   * @private
	   * @type {ItemList}
	   */
	  var tagNodes = createList();
	  /**
	   * Temp buffer of tag attributes
	   * @private
	   * @type {ItemList}
	   */
	  var tagNodesAttrName = createList();

	  /**
	   * Cache for nested tags checks
	   * @type {{}}
	   */
	  var nestedTagsMap = {};

	  var isTokenNested = function isTokenNested(token) {
	    if (typeof nestedTagsMap[token.getValue()] === 'undefined') {
	      nestedTagsMap[token.getValue()] = tokenizer.isTokenNested(token);
	    }

	    return nestedTagsMap[token.getValue()];
	  };

	  var isTagNested = function isTagNested(tagName) {
	    return !!nestedTagsMap[tagName];
	  };

	  /**
	   * Flushes temp tag nodes and its attributes buffers
	   * @private
	   * @return {Array}
	   */
	  var flushTagNodes = function flushTagNodes() {
	    if (tagNodes.flushLast()) {
	      tagNodesAttrName.flushLast();
	    }
	  };

	  /**
	   * @private
	   * @return {Array}
	   */
	  var getNodes = function getNodes() {
	    var lastNestedNode = nestedNodes.getLast();

	    return lastNestedNode ? lastNestedNode.content : nodes.toArray();
	  };

	  /**
	   * @private
	   * @param {TagNode} tag
	   */
	  var appendNodes = function appendNodes(tag) {
	    getNodes().push(tag);
	  };

	  /**
	   * @private
	   * @param {String} value
	   * @return {boolean}
	   */
	  var isAllowedTag = function isAllowedTag(value) {
	    if (options.onlyAllowTags && options.onlyAllowTags.length) {
	      return options.onlyAllowTags.indexOf(value) >= 0;
	    }

	    return true;
	  };

	  /**
	   * @private
	   * @param {Token} token
	   */
	  var handleTagStart = function handleTagStart(token) {
	    flushTagNodes();

	    var tagNode = TagNode.create(token.getValue());
	    var isNested = isTokenNested(token);

	    tagNodes.push(tagNode);

	    if (isNested) {
	      nestedNodes.push(tagNode);
	    } else {
	      appendNodes(tagNode);
	    }
	  };

	  /**
	   * @private
	   * @param {Token} token
	   */
	  var handleTagEnd = function handleTagEnd(token) {
	    flushTagNodes();

	    var lastNestedNode = nestedNodes.flushLast();

	    if (lastNestedNode) {
	      appendNodes(lastNestedNode);
	    } else if (options.onError) {
	      var tag = token.getValue();
	      var line = token.getLine();
	      var column = token.getColumn();

	      options.onError({
	        message: 'Inconsistent tag \'' + tag + '\' on line ' + line + ' and column ' + column,
	        tagName: tag,
	        lineNumber: line,
	        columnNumber: column
	      });
	    }
	  };

	  /**
	   * @private
	   * @param {Token} token
	   */
	  var handleTag = function handleTag(token) {
	    // [tag]
	    if (token.isStart()) {
	      handleTagStart(token);
	    }

	    // [/tag]
	    if (token.isEnd()) {
	      handleTagEnd(token);
	    }
	  };

	  /**
	   * @private
	   * @param {Token} token
	   */
	  var handleNode = function handleNode(token) {
	    /**
	     * @type {TagNode}
	     */
	    var lastTagNode = tagNodes.getLast();
	    var tokenValue = token.getValue();
	    var isNested = isTagNested(token);

	    if (lastTagNode) {
	      if (token.isAttrName()) {
	        tagNodesAttrName.push(tokenValue);
	        lastTagNode.attr(tagNodesAttrName.getLast(), '');
	      } else if (token.isAttrValue()) {
	        var attrName = tagNodesAttrName.getLast();

	        if (attrName) {
	          lastTagNode.attr(attrName, tokenValue);
	          tagNodesAttrName.flushLast();
	        } else {
	          lastTagNode.attr(tokenValue, tokenValue);
	        }
	      } else if (token.isText()) {
	        if (isNested) {
	          lastTagNode.append(tokenValue);
	        } else {
	          appendNodes(tokenValue);
	        }
	      } else if (token.isTag()) {
	        // if tag is not allowed, just past it as is
	        appendNodes(token.toString());
	      }
	    } else if (token.isText()) {
	      appendNodes(tokenValue);
	    } else if (token.isTag()) {
	      // if tag is not allowed, just past it as is
	      appendNodes(token.toString());
	    }
	  };

	  /**
	   * @private
	   * @param {Token} token
	   */
	  var onToken = function onToken(token) {
	    if (token.isTag() && isAllowedTag(token.getName())) {
	      handleTag(token);
	    } else {
	      handleNode(token);
	    }
	  };

	  tokenizer = (opts.createTokenizer ? opts.createTokenizer : createLexer)(input, {
	    onToken: onToken,
	    onlyAllowTags: options.onlyAllowTags,
	    openTag: options.openTag,
	    closeTag: options.closeTag,
	    enableEscapeTags: options.enableEscapeTags
	  });

	  // eslint-disable-next-line no-unused-vars
	  var tokens = tokenizer.tokenize();

	  return nodes.toArray();
	};

	exports.default = parse;
	exports.parse = parse;
	exports.TagNode = TagNode_2;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
