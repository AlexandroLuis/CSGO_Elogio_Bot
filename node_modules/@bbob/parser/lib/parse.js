'use strict';

exports.__esModule = true;
exports.parse = undefined;

var _TagNode = require('@bbob/plugin-helper/lib/TagNode');

var _TagNode2 = _interopRequireDefault(_TagNode);

var _lexer = require('./lexer');

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @public
 * @param {String} input
 * @param {Object} opts
 * @param {Function} opts.createTokenizer
 * @param {Array<string>} opts.onlyAllowTags
 * @param {String} opts.openTag
 * @param {String} opts.closeTag
 * @param {Boolean} opts.enableEscapeTags
 * @return {Array}
 */
var parse = function parse(input) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var options = opts;

  var tokenizer = null;

  /**
   * Result AST of nodes
   * @private
   * @type {ItemList}
   */
  var nodes = (0, _utils.createList)();
  /**
   * Temp buffer of nodes that's nested to another node
   * @private
   * @type {ItemList}
   */
  var nestedNodes = (0, _utils.createList)();
  /**
   * Temp buffer of nodes [tag..]...[/tag]
   * @private
   * @type {ItemList}
   */
  var tagNodes = (0, _utils.createList)();
  /**
   * Temp buffer of tag attributes
   * @private
   * @type {ItemList}
   */
  var tagNodesAttrName = (0, _utils.createList)();

  /**
   * Cache for nested tags checks
   * @type {{}}
   */
  var nestedTagsMap = {};

  var isTokenNested = function isTokenNested(token) {
    if (typeof nestedTagsMap[token.getValue()] === 'undefined') {
      nestedTagsMap[token.getValue()] = tokenizer.isTokenNested(token);
    }

    return nestedTagsMap[token.getValue()];
  };

  var isTagNested = function isTagNested(tagName) {
    return !!nestedTagsMap[tagName];
  };

  /**
   * Flushes temp tag nodes and its attributes buffers
   * @private
   * @return {Array}
   */
  var flushTagNodes = function flushTagNodes() {
    if (tagNodes.flushLast()) {
      tagNodesAttrName.flushLast();
    }
  };

  /**
   * @private
   * @return {Array}
   */
  var getNodes = function getNodes() {
    var lastNestedNode = nestedNodes.getLast();

    return lastNestedNode ? lastNestedNode.content : nodes.toArray();
  };

  /**
   * @private
   * @param {TagNode} tag
   */
  var appendNodes = function appendNodes(tag) {
    getNodes().push(tag);
  };

  /**
   * @private
   * @param {String} value
   * @return {boolean}
   */
  var isAllowedTag = function isAllowedTag(value) {
    if (options.onlyAllowTags && options.onlyAllowTags.length) {
      return options.onlyAllowTags.indexOf(value) >= 0;
    }

    return true;
  };

  /**
   * @private
   * @param {Token} token
   */
  var handleTagStart = function handleTagStart(token) {
    flushTagNodes();

    var tagNode = _TagNode2.default.create(token.getValue());
    var isNested = isTokenNested(token);

    tagNodes.push(tagNode);

    if (isNested) {
      nestedNodes.push(tagNode);
    } else {
      appendNodes(tagNode);
    }
  };

  /**
   * @private
   * @param {Token} token
   */
  var handleTagEnd = function handleTagEnd(token) {
    flushTagNodes();

    var lastNestedNode = nestedNodes.flushLast();

    if (lastNestedNode) {
      appendNodes(lastNestedNode);
    } else if (options.onError) {
      var tag = token.getValue();
      var line = token.getLine();
      var column = token.getColumn();

      options.onError({
        message: 'Inconsistent tag \'' + tag + '\' on line ' + line + ' and column ' + column,
        tagName: tag,
        lineNumber: line,
        columnNumber: column
      });
    }
  };

  /**
   * @private
   * @param {Token} token
   */
  var handleTag = function handleTag(token) {
    // [tag]
    if (token.isStart()) {
      handleTagStart(token);
    }

    // [/tag]
    if (token.isEnd()) {
      handleTagEnd(token);
    }
  };

  /**
   * @private
   * @param {Token} token
   */
  var handleNode = function handleNode(token) {
    /**
     * @type {TagNode}
     */
    var lastTagNode = tagNodes.getLast();
    var tokenValue = token.getValue();
    var isNested = isTagNested(token);

    if (lastTagNode) {
      if (token.isAttrName()) {
        tagNodesAttrName.push(tokenValue);
        lastTagNode.attr(tagNodesAttrName.getLast(), '');
      } else if (token.isAttrValue()) {
        var attrName = tagNodesAttrName.getLast();

        if (attrName) {
          lastTagNode.attr(attrName, tokenValue);
          tagNodesAttrName.flushLast();
        } else {
          lastTagNode.attr(tokenValue, tokenValue);
        }
      } else if (token.isText()) {
        if (isNested) {
          lastTagNode.append(tokenValue);
        } else {
          appendNodes(tokenValue);
        }
      } else if (token.isTag()) {
        // if tag is not allowed, just past it as is
        appendNodes(token.toString());
      }
    } else if (token.isText()) {
      appendNodes(tokenValue);
    } else if (token.isTag()) {
      // if tag is not allowed, just past it as is
      appendNodes(token.toString());
    }
  };

  /**
   * @private
   * @param {Token} token
   */
  var onToken = function onToken(token) {
    if (token.isTag() && isAllowedTag(token.getName())) {
      handleTag(token);
    } else {
      handleNode(token);
    }
  };

  tokenizer = (opts.createTokenizer ? opts.createTokenizer : _lexer.createLexer)(input, {
    onToken: onToken,
    onlyAllowTags: options.onlyAllowTags,
    openTag: options.openTag,
    closeTag: options.closeTag,
    enableEscapeTags: options.enableEscapeTags
  });

  // eslint-disable-next-line no-unused-vars
  var tokens = tokenizer.tokenize();

  return nodes.toArray();
};

exports.parse = parse;
exports.default = parse;